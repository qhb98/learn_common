## hill climbing 爬山算法

### 一、基本概念

本质是一种局部搜索算法, 在增加高度/值的方向上连续移动, 以找到山峰或者最佳解决问题的方法. 在达到峰值时终止, 没有邻居具有更高的值.

主要的特征:

    + 生成和测试变体 -- hill climbing 是 generate 和 test 方法的变体, 生成和测试方法产生反馈, 有助于确定在搜索空间中移动的方向
    + 贪婪的方法  --  爬山算法搜索朝着优化成本的方向发展
    + 没有回溯  --  不会回溯搜索空间, 因为不记得以前的状态

[爬山算法的空间示意图](/or/heuristic_algorithm/爬山算法/hc_figures/爬山的国家空间图.png)

状态的不同区域:

    + 局部最大值  local maximum
    + 全局最大值  global maximum
    + 当前状态  current state
    + 平局局部最大值  "flat" local maximum
    + 肩部  shoulder

### 二、爬山类型算法

#### 2.1 简单爬山算法

简单的爬山是实现爬山算法的最简单方法
它一次只评估邻居节点状态，并选择第一个优化当前成本并将其设置为当前状态的状态
它只检查它的一个后继状态，如果它发现优于当前状态，则移动其他状态

    step1 评估初始状态, 如果是目标状态, 则返回成功并停止
    step2 循环直到找到解决方案或没有新的运算符可供应用
    step3 选择并将运算符应用于当前状态
    step4 检查新状态:
        如果是目标状态, 则返回成功并退出
        否则, 如果优于当前状态, 则将新状态指定为当前状态
        否则, 如果不比当前状态好, 则返回 step2
    step5 退出

#### 2.2 steepest-ascent 最速爬坡爬山算法

最陡峭的Ascent算法是简单爬山算法的变体
该算法检查当前状态的所有相邻节点，并选择最接近目标状态的一个邻居节点
该算法在搜索多个邻居时会消耗更多时间

    step1 评估初始状态, 如果是目标状态, 则返回成功并停止, 否则将当前状态作为初始状态
    step2 循环直到找到解决方案或当前状态不变
        让SUCC成为一个状态, 使得当前状态的任何继承者都会比它更好
        对于适用于当前状态的每个运算符:
            应用new运算符并生成新状态
            评估新的状态
            如果是目标状态, 则返回并退出, 否则将其与SUCC进行比较
            如果它优于SUCC, 则将新状态设置为SUCC
            如果SUCC优于当前状态, 则将当前状态设置为SUCC
    step3 退出

#### 2.3 随机爬山
随机爬山在移动之前不会检查其所有邻居
相反，该搜索算法随机选择一个邻居节点并决定是将其选择为当前状态还是检查另一个状态

### 三、爬山算法存在的问题

#### 3.1 局部最大值
局部最大值是景观中的峰值状态，其优于每个相邻状态，但是还存在另一个高于局部最大值的状态

解决方案: 回溯技术可以解决状态空间景观中的局部最大值, 创建有前途的路径列表, 以便算法可以回溯搜索空间并探索其他路径.

#### 3.2 高原
高原是搜索空间的平坦区域，其中当前状态的所有邻居状态包含相同的值，因为该算法没有找到任何最佳移动方向
在高原地区可能会失去爬山搜索

解决方案: 高原的解决方案是在搜索时采取大步骤或非常小的步骤来解决问题. 随机选择远离当前状态的状态，因此算法可能找到非平稳区域

#### 3.3 山脊
山脊是局部最大值的特殊形式
它的面积高于周围区域，但本身有一个斜坡，一次搬不到

解决方案：通过使用双向搜索或向不同方向移动，可以改善此问题







